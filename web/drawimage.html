<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <!-- 引入Element Plus CSS -->
  <link rel="stylesheet" href="./common/index.css">
  <!-- 引入Vue -->
  <script src="./common/global.js"></script>
  <!-- 引入Element Plus JS -->
  <script src="./common/index.full.js"></script>
  <title>绘图工具（固定预设尺寸）</title>
  <style>
.app-container {
      display: flex;
      min-height: 100vh;
      background-color: #f0f0f0;
      box-sizing: border-box;
      padding: 20px;
    }

    .toolbar {
      background-color: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      width: 420px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      flex-shrink: 0;
      margin-right: 20px;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
      overflow-x: hidden;
      box-sizing: border-box;
    }

    .tool-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 0; /* 防止flex项目溢出 */
    }

    .tool-label {
      font-weight: 500;
      color: #333;
      font-size: 14px;
    }

    ..canvas-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
      position: relative;
      overflow: hidden;
    }

    .canvas-wrapper {
      position: relative;
      cursor: grab;
      user-select: none;
    }

    .canvas-wrapper.dragging {
      cursor: grabbing;
    }

    .button-group {
      display: flex;
      gap: 10px;
    }

    .btn {
      margin: 0 5px;
    }

    .brush-preview {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 auto;
      border: 1px solid #ddd;
    }

    .size-value {
      text-align: center;
      font-size: 14px;
      color: #666;
    }

    .canvas-size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .canvas-size-input {
      width: 80px;
    }

    .apply-size-btn {
      width: 100%;
      margin-top: 5px;
    }

    .ratio-info {
      font-size: 12px;
      color: #888;
      text-align: center;
      margin-top: 5px;
    }
  </style>
</head>
<body style="margin: 0px;">
  <div id="app" class="app-container">
    <!-- 左侧工具栏 -->
    <div class="toolbar">
      <div>绘图工具</div>
      <div class="button-group">
        <el-button type="primary" plain class="btn" @click="sendCanvasImage">发送图像</el-button>
        <el-button plain class="btn" @click="clearCanvas">清空画布</el-button>
      </div>

      <!-- 画布大小设置（固定预设尺寸） -->
      <div class="tool-group">
        <div class="tool-label">画布尺寸选择</div>
        <div class="size-value">
          当前尺寸: {{ canvasWidth }} × {{ canvasHeight }}---比例: {{ getRatioText() }}
        </div>
<div style="display: inline-block; flex-direction: column; gap: 8px; margin-top: 10px;">
          <el-button
            type="primary"
            size="small"
            style="width: 80px;"
            @click="setPresetSize(600, 600)"
          >
          (600×600)
          </el-button>
          <el-button
            type="primary"
            size="small"
            style="width: 80px;"
            @click="setPresetSize(750, 424)"
          >
          (750×424)
          </el-button>
          <el-button
            type="primary"
            size="small"
            style="width: 80px;"
            @click="setPresetSize(424, 750)"
          >
          (424×750)
          </el-button>
        </div>
      </div>

      <!-- 画笔大小调整 -->
      <div class="tool-group">
        <div class="tool-label">画笔大小</div>
        <el-slider
          v-model="brushSize"
          :min="1"
          :max="50"
          :step="1"
          @change="updateBrushSettings"
        ></el-slider>
        <div class="size-value">{{ brushSize }}px</div>
        <div class="brush-preview" :style="{
          backgroundColor: brushColor,
          opacity: brushOpacity,
          transform: `scale(${brushSize / 20})`
        }"></div>
      </div>
      <!-- 透明度调整 -->
      <div class="tool-group">
        <div class="tool-label">透明度={{ Math.round(brushOpacity * 100) }}%</div>
        <el-slider
          v-model="brushOpacity"
          :min="0"
          :max="1"
          :step="0.1"
          @change="updateBrushSettings"
        ></el-slider>
      </div>


<!-- 画笔颜色和预设颜色 -->
      <div class="tool-group">
        <div class="tool-label">画笔颜色</div>
        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
          <el-color-picker
            v-model="brushColor"
            show-alpha
            @change="updateBrushSettings"
          ></el-color-picker>
          <div style="display: flex; flex-wrap: wrap; gap: 6px; min-width: 0;">
            <div
              v-for="color in presetColors"
              :key="color"
              class="color-preset"
              :style="{ backgroundColor: color }"
              @click="selectPresetColor(color)"
            ></div>
          </div>
        </div>
      </div>

<!-- 背景颜色设置 -->
      <div class="tool-group">
        <div class="tool-label">背景颜色</div>
        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
          <el-color-picker
            v-model="backgroundColor"
            @change="changeBackgroundColor"
          ></el-color-picker>
          <div style="display: flex; flex-wrap: wrap; gap: 6px; min-width: 0;">
            <div
              v-for="color in presetColors"
              :key="color"
              class="color-preset"
              :style="{ backgroundColor: color }"
              @click="selectBackgroundPresetColor(color)"
            ></div>
          </div>
        </div>
      </div>
    </div>

<!-- 绘图区域 -->
    <div class="canvas-container">
      <div
        class="canvas-wrapper"
        :class="{ dragging: isDragging }"
        :style="`transform: translate(${translateX}px, ${translateY}px) scale(${scale});`"
      >
        <canvas
          id="drawCanvas"
          :width="canvasWidth"
          :height="canvasHeight"
          :style="`border:1px solid #ccc;background:${backgroundColor};cursor:crosshair;box-shadow: 0 2px 10px rgba(0,0,0,0.1);transform-origin: top left;`"
        ></canvas>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, reactive } = Vue;
    const { ElSlider, ElColorPicker, ElButton, ElInput } = ElementPlus;

    const App = {
      components: {
        ElSlider,
        ElColorPicker,
        ElButton,
        ElInput
      },
      data() {
return {
          canvas: null,
          ctx: null,
          drawing: false,
          lastX: 0,
          lastY: 0,
          // 实际画布尺寸（默认正方形400×400）
          canvasWidth: 600,
          canvasHeight: 600,
// 画笔设置
          brushSize: 3,
          brushColor: '#FF0000',
          brushOpacity: 1,
          // 背景颜色设置
          backgroundColor: '#ffffff',
          // 预设颜色
          presetColors: [
            '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF',
            '#FFFF00', '#FF00FF', '#00FFFF', '#888888', '#FFA500'
          ],
          // 缩放和平移相关
          scale: 1,
          translateX: 0,
          translateY: 0,
          isDragging: false,
          dragStartX: 0,
          dragStartY: 0
        };
      },
      mounted() {
        this.initCanvas();
        window.parent.postMessage({ ready: true }, '*');

        // 接收来自父窗口的初始化数据（尺寸和base64）
        window.addEventListener('message', (e) => {
          if (e.data.modalId === 0) {
            // 接收尺寸信息（优先使用保存的尺寸）
            if (e.data.width && e.data.height) {
              this.canvasWidth = e.data.width;
              this.canvasHeight = e.data.height;
              this.applyCanvasSize(); // 应用尺寸
            }
            // 接收base64数据并渲染（保持原始宽高比）
            if (e.data.base64 && e.data.base64.startsWith('data:')) {
              const img = new Image();
img.onload = () => {
                // 填充当前背景色
                this.ctx.fillStyle = this.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                // 保持图片原始宽高比，居中绘制
                const imgRatio = img.width / img.height;
                const canvasRatio = this.canvas.width / this.canvas.height;

                let drawWidth, drawHeight, offsetX, offsetY;
                if (imgRatio > canvasRatio) {
                  // 图片更宽，按宽度适配
                  drawWidth = this.canvas.width;
                  drawHeight = this.canvas.width / imgRatio;
                  offsetX = 0;
                  offsetY = (this.canvas.height - drawHeight) / 2;
                } else {
                  // 图片更高，按高度适配
                  drawHeight = this.canvas.height;
                  drawWidth = this.canvas.height * imgRatio;
                  offsetX = (this.canvas.width - drawWidth) / 2;
                  offsetY = 0;
                }

                this.ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
              };
              img.src = e.data.base64;
            }
          }
        });
      },
      methods: {
// 初始化画布
        initCanvas() {
          this.canvas = document.getElementById('drawCanvas');
          this.ctx = this.canvas.getContext('2d');

// 初始化背景颜色
          this.ctx.fillStyle = this.backgroundColor;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // 初始化线条样式
          this.updateBrushSettings();

          // 绘图事件监听
          this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
          this.canvas.addEventListener('mousemove', this.draw.bind(this));
          this.canvas.addEventListener('mouseup', this.endDrawing.bind(this));
          this.canvas.addEventListener('mouseout', this.endDrawing.bind(this));

          // 缩放和平移事件监听
          const canvasWrapper = this.canvas.parentElement;

          // 简化滚轮处理，直接绑定到canvas-wrapper
          canvasWrapper.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
              e.preventDefault();
              e.stopPropagation();
              const delta = e.deltaY > 0 ? 0.9 : 1.1;
              this.scale = Math.max(0.1, Math.min(5, this.scale * delta));
              console.log('Scale:', this.scale);
            }
          });

          canvasWrapper.addEventListener('mousedown', this.startDrag.bind(this));
          canvasWrapper.addEventListener('mousemove', this.drag.bind(this));
          canvasWrapper.addEventListener('mouseup', this.endDrag.bind(this));
          canvasWrapper.addEventListener('contextmenu', (e) => e.preventDefault());

          // 触摸设备支持
          this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.startDrawing(this.getTouchPosition(e));
          });
          this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.draw(this.getTouchPosition(e));
          });
          this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.endDrawing();
          });
        },

        // 获取触摸位置（用于移动设备）
        getTouchPosition(e) {
          const touch = e.touches[0];
          const rect = this.canvas.getBoundingClientRect();
          return {
            clientX: touch.clientX,
            clientY: touch.clientY,
            target: e.target
          };
        },

        // 更新画笔设置
        updateBrushSettings() {
          if (!this.ctx) return;
          this.ctx.lineWidth = this.brushSize;
          this.ctx.strokeStyle = this.brushColor;
          this.ctx.globalAlpha = this.brushOpacity;
          this.ctx.lineCap = 'round';
          this.ctx.lineJoin = 'round'; // 使线条连接更平滑
        },

// 选择预设颜色
        selectPresetColor(color) {
          this.brushColor = color;
          this.updateBrushSettings();
        },

// 处理滚轮缩放
        handleWheel(e) {
          console.log('Wheel event detected:', e.ctrlKey, e.deltaY); // 调试信息
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            e.stopPropagation();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.scale = Math.max(0.1, Math.min(5, this.scale * delta));
            console.log('Scale:', this.scale); // 调试信息
          }
        },

        // 开始拖拽
        startDrag(e) {
          if (e.button === 2) { // 右键
            e.preventDefault();
            this.isDragging = true;
            this.dragStartX = e.clientX - this.translateX;
            this.dragStartY = e.clientY - this.translateY;
          }
        },

        // 拖拽中
        drag(e) {
          if (this.isDragging) {
            e.preventDefault();
            this.translateX = e.clientX - this.dragStartX;
            this.translateY = e.clientY - this.dragStartY;
          }
        },

        // 结束拖拽
        endDrag() {
          this.isDragging = false;
        },

        startDrawing(e) {
          if (e.button === 0) { // 左键
            this.drawing = true;
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            this.lastX = (e.clientX - rect.left) * scaleX;
            this.lastY = (e.clientY - rect.top) * scaleY;
          }
        },

draw(e) {
          if (!this.drawing) return;
          const rect = this.canvas.getBoundingClientRect();
          const scaleX = this.canvas.width / rect.width;
          const scaleY = this.canvas.height / rect.height;
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;

          this.ctx.beginPath();
          this.ctx.moveTo(this.lastX, this.lastY);
          this.ctx.lineTo(x, y);
          this.ctx.stroke();
          [this.lastX, this.lastY] = [x, y];
        },

        endDrawing() {
          this.drawing = false;
        },

        getPosition(e) {
          const rect = this.canvas.getBoundingClientRect();
          return [
            e.clientX - rect.left,
            e.clientY - rect.top
          ];
        },

// 清空画布
        clearCanvas() {
          this.ctx.fillStyle = this.backgroundColor;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        },

        // 改变背景颜色
        changeBackgroundColor(color) {
          this.backgroundColor = color;
          this.applyBackground();
        },

        // 选择背景预设颜色
        selectBackgroundPresetColor(color) {
          this.backgroundColor = color;
          this.applyBackground();
        },

        // 应用背景颜色
        applyBackground() {
          // 保存当前画布内容
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = this.canvas.width;
          tempCanvas.height = this.canvas.height;
          tempCtx.drawImage(this.canvas, 0, 0);

          // 填充新背景
          this.ctx.fillStyle = this.backgroundColor;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // 恢复画布内容
          this.ctx.drawImage(tempCanvas, 0, 0);
        },

        // 发送画布图像（保持原始宽高）
        sendCanvasImage() {
          const dataURL = this.canvas.toDataURL('image/png');
          const msg = {
            Id: 0,
            data: dataURL,
            width: this.canvasWidth, // 原始宽度
            height: this.canvasHeight, // 原始高度
            ratio: this.getRatioText() // 宽高比
          };
          // 发送到父窗口
          window.parent.postMessage(msg, '*');
          console.log("图像已发送到后端（保持宽高比）", msg);
        },

        // 应用画布尺寸（切换尺寸时保留绘图内容）
        applyCanvasSize() {
          // 保存当前画布内容
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = this.canvas ? this.canvas.width : 0;
          tempCanvas.height = this.canvas ? this.canvas.height : 0;
          if (this.canvas) {
            tempCtx.drawImage(this.canvas, 0, 0);
          }

          // 重新初始化画布
          this.initCanvas();

          // 恢复画布内容（保持原始宽高比）
          if (tempCanvas.width > 0 && tempCanvas.height > 0) {
            const tempRatio = tempCanvas.width / tempCanvas.height;
            const canvasRatio = this.canvas.width / this.canvas.height;

            let drawWidth, drawHeight, offsetX, offsetY;
            if (tempRatio > canvasRatio) {
              drawWidth = this.canvas.width;
              drawHeight = this.canvas.width / tempRatio;
              offsetX = 0;
              offsetY = (this.canvas.height - drawHeight) / 2;
            } else {
              drawHeight = this.canvas.height;
              drawWidth = this.canvas.height * tempRatio;
              offsetX = (this.canvas.width - drawWidth) / 2;
              offsetY = 0;
            }

            this.ctx.drawImage(
              tempCanvas,
              offsetX, offsetY, drawWidth, drawHeight
            );
          }

          // 更新画笔设置
          this.updateBrushSettings();
        },

        // 设置预设尺寸（固定尺寸）
        setPresetSize(width, height) {
          this.canvasWidth = width;
          this.canvasHeight = height;
          this.applyCanvasSize();
        },

        // 获取比例文本（简化为最简分数）
        getRatioText() {
          const gcd = this.calculateGCD(this.canvasWidth, this.canvasHeight);
          const w = this.canvasWidth / gcd;
          const h = this.canvasHeight / gcd;
          return `${w}:${h}`;
        },

        // 计算最大公约数（用于简化比例）
        calculateGCD(a, b) {
          return b === 0 ? a : this.calculateGCD(b, a % b);
        }
      },
      watch: {
        // 监听尺寸变化，确保canvas元素尺寸同步
        canvasWidth() {
          if (this.canvas) {
            this.canvas.width = this.canvasWidth;
          }
        },
        canvasHeight() {
          if (this.canvas) {
            this.canvas.height = this.canvasHeight;
          }
        }
      }
    };

    const app = createApp(App);
    app.use(ElementPlus);
    app.mount("#app");
  </script>

  <style>
    .color-preset {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
      border: 1px solid #ddd;
    }

.color-preset:hover {
      transform: scale(1.1);
    }

    .background-preview {
      width: 40px;
      height: 40px;
      border: 2px solid #ddd;
      border-radius: 4px;
      transition: border-color 0.2s;
    }

    .background-preview:hover {
      border-color: #409eff;
    }
  </style>
</body>
</html>